# R√®gles et Conventions pour Polytopia-JAX

## Architecture du Projet

### S√©paration stricte des responsabilit√©s

Le projet suit une architecture modulaire avec s√©paration stricte :

1. **`polytopia_jax/core/`** : Moteur de jeu pur en JAX
   - Aucune d√©pendance externe (pas d'IO, pas d'√©tat mutable)
   - Toutes les fonctions doivent √™tre compatibles avec `jit` et `vmap`
   - Utilise uniquement `jax.numpy` et structures Flax `@struct.dataclass`
   - Les √©tats sont des pytrees JAX statiques

2. **`polytopia_jax/ai/`** : Strat√©gies IA
   - Peut utiliser le moteur core mais reste ind√©pendant
   - Strat√©gies disponibles : `rush`, `economy`, `random`, `idle`

3. **`rl/`** : Wrappers pour l'apprentissage par renforcement
   - Gymnasium (single-agent) et PettingZoo (multi-agent)
   - Imports conditionnels pour d√©pendances optionnelles

4. **`polytopia_jax/web/`** : Backend FastAPI
   - Conversion `GameState` ‚Üí `GameStateView` (s√©rialisable)
   - Gestion des replays et parties live
   - Aucune logique de jeu, uniquement s√©rialisation/API

5. **`frontend/`** : Interface React + TypeScript
   - Aucune logique de jeu, uniquement affichage
   - Communication via API REST
   - SVG pour le rendu du plateau

## Conventions de Code Python

### JAX et Flax

- **Toujours utiliser `jax.numpy`** au lieu de `numpy` pour les calculs dans le core
- **Utiliser `@struct.dataclass`** de Flax pour les structures d'√©tat (pas `@dataclass` standard)
- **Tous les champs doivent √™tre des arrays JAX** (`jnp.ndarray`) pour permettre `jit` et `vmap`
- **Pas de mutations** : cr√©er de nouveaux √©tats plut√¥t que modifier l'existant
- **Utiliser `jax.lax`** pour les op√©rations conditionnelles dans les fonctions trac√©es

### Types et Constantes

- **Enums** : Utiliser `IntEnum` pour les types (UnitType, TerrainType, etc.)
- **Constantes de taille** : Toujours d√©finir `NUM_TYPES`, `NUM_ACTIONS`, etc. pour les boucles
- **NO_OWNER** : Utiliser `-1` pour indiquer l'absence de propri√©taire

### Nommage

- **Classes** : PascalCase (`GameState`, `ActionType`)
- **Fonctions** : snake_case (`encode_action`, `legal_actions_mask`)
- **Constantes** : UPPER_SNAKE_CASE (`MAX_UNIT_TYPES`, `NO_OWNER`)
- **Fichiers** : snake_case (`state.py`, `actions.py`)

### Actions

- **Encodage** : Les actions sont encod√©es en un seul entier (30 bits max)
- **Format** : `ActionType` (3 bits) + param√®tres optionnels (unit_id, direction, target_pos, unit_type)
- **D√©codage** : Utiliser `decode_action()` qui g√®re le contexte trac√©

### Syst√®me de Grille

- **Coordonn√©es** : Syst√®me de grille simple align√© (x, y), pas hexagonal logique
- **Directions** : 8 directions avec deltas {-1, 0, 1} en x et {-1, 0, 1} en y
- **Rendu** : Hexagonal visuel mais coordonn√©es logiques align√©es

## Conventions de Code TypeScript/React

### Structure des Composants

- **Composants fonctionnels** : Toujours utiliser des fonctions, pas de classes
- **Hooks** : Utiliser les hooks React standards (`useState`, `useEffect`, etc.)
- **Types** : D√©finir tous les types dans `types.ts` (pas de types inline)

### Nommage Frontend

- **Composants** : PascalCase (`Board.tsx`, `LiveGameView.tsx`)
- **Fonctions** : camelCase (`fetchGameState`, `handleAction`)
- **Types/Interfaces** : PascalCase (`GameStateView`, `UnitView`)
- **Constantes** : UPPER_SNAKE_CASE ou objets `as const` (`TerrainType`, `UnitType`)

### API Client

- **Fichier unique** : Toutes les fonctions API dans `api.ts`
- **Types** : Utiliser les types d√©finis dans `types.ts`
- **Erreurs** : G√©rer les erreurs avec try/catch et afficher des messages utilisateur

### Rendu SVG

- **Optimisation mobile** : Le rendu SVG doit √™tre optimis√© pour les √©crans tactiles
- **Coordonn√©es** : Utiliser le syst√®me de grille align√©, convertir en coordonn√©es hexagonales pour l'affichage

## Tests

### Structure des Tests

- **Nommage** : `test_*.py` pour les fichiers, `test_*` pour les fonctions
- **Organisation** : Miroir de la structure du code (`test_core/`, `test_web/`, `test_ai/`)
- **Fixtures** : Stocker dans `tests/test_web/fixtures/` pour les donn√©es de test

### Bonnes Pratiques

- Tester les transitions d'√©tat √©l√©mentaires (`step`, mouvements, combats)
- Tester les masques d'actions l√©gales
- Tester la s√©rialisation/d√©s√©rialisation
- Utiliser `pytest` avec `-v` pour la verbosit√©

## Documentation

### Docstrings Python

- **Format** : Utiliser des docstrings Google-style
- **Sections** : Inclure `Args:`, `Returns:`, `Raises:` si n√©cessaire
- **Exemples** : Ajouter des exemples pour les fonctions complexes

### Commentaires

- **Phase** : Documenter la phase de d√©veloppement (Phase 0, Phase 1, etc.)
- **Limitations** : Mentionner les limitations connues dans les docstrings
- **TODO** : Utiliser `# TODO:` pour les am√©liorations futures

## Gestion des Versions et Phases

Le projet suit une feuille de route par phases :

- **Phase 0** : MVP avec unit√©s WARRIOR uniquement ‚úÖ
- **Phase 1** : Boucle √©conomique minimale ‚úÖ
- **Phase 2** : Progression des villes et scoring ‚úÖ
- **Phase 3** : Arbre technologique ‚úÖ
- **Phase 4** : Diversit√© d'unit√©s terrestres ‚úÖ
- **Phase 5** : Navigation et terrains avanc√©s ‚úÖ
- **Phase 6** : IA et difficult√©s ‚úÖ
- **Phase 7** : Contenus avanc√©s üöß

Lors de l'ajout de nouvelles fonctionnalit√©s, v√©rifier la phase actuelle et documenter les limitations.

## D√©pendances

### Backend

- **Obligatoires** : `jax`, `jaxlib`, `flax`, `numpy`, `fastapi`, `uvicorn`, `pydantic`
- **Optionnelles** : `gymnasium`, `pettingzoo` (imports conditionnels)

### Frontend

- **Core** : `react`, `react-dom`, `typescript`
- **Build** : `vite`, `tailwindcss`
- **Dev** : `@typescript-eslint/*`, `eslint`

## Commandes Utiles

### Backend

```bash
# Activer l'environnement virtuel
source venv/bin/activate

# Installer en mode d√©veloppement
pip install -e .

# Lancer le serveur
uvicorn polytopia_jax.web.api:app --reload

# Tests
pytest tests/ -v
```

### Frontend

```bash
cd frontend
npm install
npm run dev
npm run build
```

## R√®gles Importantes

1. **Ne jamais m√©langer les couches** : Le core ne doit jamais importer web ou frontend
2. **Pas d'IO dans le core** : Aucune lecture/√©criture de fichiers dans `polytopia_jax/core/`
3. **S√©rialisation s√©par√©e** : La conversion `GameState` ‚Üí JSON se fait uniquement dans `web/`
4. **Types synchronis√©s** : Les types TypeScript doivent correspondre aux mod√®les Pydantic
5. **Tests avant commit** : Toujours ex√©cuter les tests avant de commiter

## Patterns Sp√©cifiques au Projet

### Masques d'Actions

- Toujours v√©rifier les actions l√©gales avec `legal_actions_mask()`
- Le masque doit √™tre calcul√© c√¥t√© core, pas c√¥t√© web/frontend

### Gestion des Unit√©s

- Utiliser des tableaux de taille fixe `[N_units_max]` avec un flag `units_active`
- Les unit√©s inactives ont `units_active[i] = False`

### Gestion des Villes

- Les villes sont stock√©es dans des arrays `[H, W]`
- `city_owner[i, j] = -1` signifie pas de ville
- `city_level[i, j] = 0` signifie pas de ville ou ville de niveau 0

### Scores et R√©compenses

- Les scores sont calcul√©s dans `core/score.py`
- Les r√©compenses RL sont dans `core/reward.py`
- Ne pas m√©langer les deux concepts






